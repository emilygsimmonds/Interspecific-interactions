---
title: "Interspecific interactions results"
author: "Emily Simmonds"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

```{r set-up, eval=TRUE, include=FALSE}
# set warning to be off for all chunks
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

#### packages

library(tidyverse)
library(INLA)
library(nimble)
library(patchwork)
library(viridis)

#### scripts

source('./Functions/summarise_data.R')
source('./Functions/RUN_RESULTS.R')
```

## Concept

In this project I will look at three types of interaction:

* Predator/prey (-/+)
* Competitive (-/-)
* Mutualist (+/+)

There are also four scenarios:

* Baseline - equal interaction strengths
* Unequal - unequal interaction strengths
* Noise - 1 = higher noise equal interactions , 2 = higher noise unequal interactions
* Correlation - changing of correlation in environmental noise from 0.3 to 0.9

</br>

This is a simulation study. 

I simultaneously simulate two time series of observed population size ($Y$) 
for species $i$ and species $j$ and the log population size. 

To do this, I use the following equations (Gompertz equations on the log-linear 
scale):

$$
Y_i \sim Pois(exp(N_i))
$$
$$
N_i = r_i + c_i N_i + \alpha_{ij} N_j + e_i
$$

$$
Y_j \sim Pois(exp(N_j))
$$
$$
N_j = r_j + c_j N_j + \alpha_{ji} N_i + e_j
$$

$$
e \sim W_p(V, n)
$$

$$
\begin{gather}
V =   
\begin{bmatrix}
   \sigma^2_{ii} &
   cov_{ij} \\
   cov_{ji} &
   \sigma^2_{jj} 
   \end{bmatrix}
\end{gather}
$$

where, 

$N$ = log actual population size, 

$r$ = intrinsic growth rate, 

$c$ = intraspecific competition (density dependence),

$\alpha$ = interspecific effect, 

$e$ = matrix of random error with rows $i$ and $j$

$n$ = degrees of freedom ($p$ -1)

$p$ = 2

$V$ = a variance covariance matrix.

<br>

Both the true population size and the observed population size including 
Poisson error are output. 

<br>

I simulate populations using the following baseline parameter values:

- starting population size = 100
- $r_i$ = $r_j$ = 1.25
- $c_i$ = $c_j$ = 0.74

The values of alpha depend on the type of interaction:

- Predator/prey: $\alpha_{ij}$ = 0.129, $\alpha_{ji}$ = -0.129
- Competitive: $\alpha_{ij}$ = $\alpha_{ji}$ = -0.129
- Mutulaist: $\alpha_{ij}$ = $\alpha_{ji}$ = 0.129

<br>

I then fit a model in either INLA or Nimble to this data to see if it can
retrieve the parameter values used to create the data. 

I also ran the Nimble model with a gridded approach, but this most often gave
an estimate of 0 for either interaction effect. 

</br>

## Results

All results focus on whether the sign of the interaction effects was correctly
retrieved. 

I also tracked whether the interaction was significantly estimated (credible
interval not spanning 0), but this was rare. 

</br>

### Scenario 1 - baseline

```{r baseline-results}

sign_correct <- results_baseline_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()


ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "baseline results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

```

</br>

A naive Nimble model did well for competition and mutualism but less well for predator prey. INLA was the opposite. 


None are recovering the correct sign 100% of the time. Sometimes are bad as <50%. 

</br>

### Scenario 2 - unequal interaction strength

```{r unequal-results}

sign_correct_unequal <- results_unequal_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()

ggplot(data = filter(sign_correct_unequal, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "unequal results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()


ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "baseline results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

```

</br>

When interaction strengths are unequal â€“ both models performs worse in returning the correct sign for interaction j on i. 

This is especially true for competition and predator prey interactions. INLA is impacted more for competition and Nimble for predator prey. 

Interaction of i on j is pretty stable (the stronger effect). 

</br>

### Scenario 3 - increased noise

**Equal interaction strength**

```{r noise-results1}

sign_correct_noise <- results_noise1_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()

ggplot(data = filter(sign_correct_noise, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "increased noise results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()


ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "baseline results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

```

</br>

**Unequal interaction strength**

```{r noise-results2}

sign_correct_noise <- results_noise2_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()

ggplot(data = filter(sign_correct_noise, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "increased noise results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()


ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "unequal results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

```

</br>

Accuracy of mean estimate sign for competition improves for both models when noise is higher. 

But predator prey sign accuracy decreases for Nimble. The rest largely unchanged.

INLA largely unchanged. 

Nimble sees reduction in sign accuracy for i on j when noise is higher (competition and predator prey) but an improvement in sign accuracy of j on i for competition. 

</br>


### Scenario 4 - different correlation strengths

**All with unequal interaction strength**

```{r corr-results}

sign_correct <- results_corr1_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()

ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "Corr = 0.9 results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

sign_correct <- results_baseline_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()


ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "Corr = 0.7 results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

sign_correct <- results_corr2_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()

ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "Corr = 0.5 results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

sign_correct <- results_corr3_all %>% 
  drop_na(sign_correct) %>%
  group_by(model, interaction_type, label, sign_correct) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count/sum(count))*100) %>%
  filter(sign_correct == TRUE) %>%
  mutate(sign_correct = droplevels(as.factor(sign_correct))) %>%
  ungroup()

ggplot(data = filter(sign_correct, 
                     label == "alpha_ionj" |
                       label == "alpha_joni",
                     model != "gridded"), 
       aes(x = interaction_type, y = percentage, fill = model))+
  geom_col(position = "dodge") +
  facet_wrap(vars(label),
             scales = "free_x") +
  labs(title = "Corr = 0.3 results: % sign correct",
       ylab = "Percentage of results",
       xlab = "Sign correct")  +
  scale_fill_viridis_d(breaks = c("gridded", "inla", "nimble")) +
  theme_minimal()

```

</br>

INLA sign accuracy for predator prey seems to decrease as correlation increases. 

Nimble is quite variable for predator prey j on i. But accuracy of i on j improves as correlation increases.

Nimble competition accuracy for j on i decreases as correlation increases. 

</br>
